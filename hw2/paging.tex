\section{Начальная таблица страниц}

Когда main получает управление код уже исполняется с включенным paging-ом, т. е
использует некоторую таблицу страниц. Эта начальная таблица страниц содержит
отображения для трех регионов виртуальной памяти на первые 2GB физической
памяти. Далее следует краткое описание каждого из них.

\paragraph{Identity Mapping.} Для перехода в 64-битный режим документация
~\cite{INTEL:SYSV3} в разделе 9.8.5 Initializing IA-32e Mode требует
отображения 1 к 1 в начальной таблице страниц. Т. е. эта часть таблицы страниц
отображает первые 4GB виртуальной памяти на первые 4GB физической\footnote{В
оригинальной версии исходников эта часть отображала только первые 2GB, и была
изменена после первого домашнего задания, т. е. не забудьте обновить свою
версию.}.

\paragraph{Участок сразу за "канонической дырой".} Этот участок в 4GB
отображается на первые 4GB физической памяти. В целом участок виртуальной памяти
начиная от "канонической дыры" до ядра предполагается использовать чтобы
отобразить его на всю физическую память. Такое отображение сделает
преобразование физического адреса в виртуальным и обратно тривиальным для данных
ядра. Однако обратите внимание, что использовать тоже самое отображение для кода
ядра не получится.

\paragraph{Последние 2GB виртуальной памяти.} Этот участок также отображается на
первые 2GB физической памяти и в этом виртуальном адресном пространстве работает
код ядра, так же обитают статические данные ядра. Этот участок используется
потому что ядро использует kernel code model~\cite{AMD64:ABI}.

Все три отображения используют страницы размеров 2MB. Вам рекомендуется создать
свою таблицу страниц взамен ограниченной начальной страницы, после того как вы
реализуете аллокатор физических страниц по следующим правилам:
\begin{itemize}
  \item отобразите верхние 2GB виртуального адресного пространства на первые 2GB
        физической памяти используя любой размер страницы\footnote{Выбор у вас
        небольшой 2MB или 4KB, очевидно использование страниц в 2MB сэкономит
        память и будет быстрее.};
  \item отобразите виртуальную память сразу за "канонической дырой" на всю
        физическую память, размер которой вам известен из карты памяти (опять
        же размер страницы остается на ваше усмотрение);
  \item не нужно задумываться о "специальных" участках физической памяти,
        которые могут отображаться на регистры устройств или дырах в физической
        памяти при построении отображения - они не доставят проблем пока вы не
        будете их использовать;
  \item отображайте все страницы с правами на запись (PTE\_WRITE в
        предоставленном файле paging.h) и без права доступа непривилегированным
        пользователям (без флага PTE\_USER из файла paging.h) - нам нет особого
        смысла заморачиваться защитой памяти ядра от самого ядра;
\end{itemize}

Детальная информация о структуре таблицы страниц, поддерживаемых размерах
страниц и флагах доступна в официальной документации~\cite{INTEL:SYSV3} в главе
4 Paging, нас более всего интересует в этой главе описание IA-32e режима
Paging-а, который мы и используем.

\paragraph{Сброс TLB.} Если вы меняете отображение, то вам необходимо сбросить
соответствующие записи в TLB. Причем, если отображения для какой-то страницы
отсутствовало в таблице страниц и вы его создали, то вы, по хорошему, должны
сбрасывать TLB и в этом случае тоже\footnote{На лекции я говорил по другому, но
это относилось только Intel-овским CPU, есть и другие производители x86-like
процессоров - и нет, это не только AMD - которые могут требовать сброса TLB
даже в таком нелепом случае.}.

Для сброса TLB есть две возможности:
\begin{itemize}
  \item перезаписать значение в cr3\footnote{Тут тоже не все так гладко, но я
        не смог вспомнить/найти проблемы связанные с этим способом - вроде
        какие-то совсем странные производители процессоров в этой ситуации
        не сбрасывали TLB.} - в этом случае сбрасывается весь TLB, чего, по
        возможности, стоит избегать;
  \item использовать инструкцию invlpg, которая старается сбрасывать из TLB
        только записи соответствующие переданному ей виртуальному адресу
        \footnote{Если инструкцию invlpg реализовать как сброс всего TLB, то это
        тоже будет корректным поведением, но на нормальных CPU сброс одной
        записи обойдется дешевле во многих смыслах.};
\end{itemize}

В предоставляемым вместе с заданием файле paging.h описаны вспомогательные
функции для работы с таблицами страниц - вам предлагается ознакомиться с ними
самостоятельно. Среди них есть функции для сброса TLB (flush\_tlb\_addr и
flush\_tlb) и записи/чтения физического адреса корневой таблицы страниц в/из
регистра cr3 (load\_pml4 и store\_pml4 соответственно).
