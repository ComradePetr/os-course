\section{Программируемый контроллер прерываний}

В рамках курса мы будем работать со старым семейством программируемых контроллеров
прерываний представленных чипами Intel из серии 8259 (8259, 8259a и 8259b). Эти
чипы уже давно не используются в реальном оборудовании поэтому мы будем
ссылаться на них как Legacy PIC. К счастью для нас, современные контроллеры
прерываний~\cite{WIKI:APIC} поддерживают интерфейс Legacy PIC, поэтому все что
вы напишите можно будет запустить и на реальном железе, а не только в эмуляторе.

Почему мы будем пользоваться Legacy PIC вместо более современных APIC? Причин
две:
\begin{itemize}
  \item Legacy PIC проще (потому что менее функциональный), соответственно
        быстрее можно получить работающее решение;
  \item чтобы использовать APIC вам все равно сначала придется настроить
        Legacy PIC, т. е. работу с Legacy PIC все равно пропустить нельзя.
\end{itemize}

Как и для любой другой электронной схемы для Legacy PIC есть спецификация:
\cite{INTEL:8259ADS}. Однако полезность этой спецификации очень ограничена. Она
описывает контакты контроллера прерываний и их назначение, но так как этот
контроллер прерываний можно подсоединить к любому процессору\footnote{по крайней
мере не только к процессорам семейства x86} она не описывает интерфейс для
обращения к контактам контроллера. Другими словами, прочитав эту спецификацию
вы буде знать какие команды передавать контроллеру прерываний, но не будете
знать как именно это сделать. Таким образом чтобы работать с Legacy PIC вам
нужно знать как он подключается и какой интерфейс для доступа к его выходам.

\subsection{Подключение}

На самом деле, в персональных компьютерах использовался не один чип, а два,
соединенных в каскад (Legacy PIC можно было соединять в каскады и из большего
числа контроллеров). Один из двух чипов называется Master, а другой,
соответственно Slave. Выход Slave чипа подсоединяется к второму входы (считая с
нуля) Master чипа. Master чип соединен напрямую с процессором.

Всего у каждого чипа по 8 входов для устройств, один из входов Master чипа
занят выходом Slave чипа, т. е. остается 15 свободных входов для подключения
внешних устройств к контроллерам прерываний. 15 внешних устройств это, на самом
деле, очень мало для современных компьютерных систем, поэтому некоторые входы
контроллеров прерываний разделяются между несколькими устройствами, но мы не
будем касаться этой темы.

\subsection{Сигнализация и обработка аппаратных прерываний}

Теперь когда мы знаем как Legacy PIC подключен к процессору рассмотрим чуть
подробнее что происходит, когда устройству требуется внимание и забота со
стороны процессора и оно генерирует прерывание.

Допустим для определенности, что, например, программируемый интервальный таймер
(PIT, о котором мы еще поговорим дальше) генерирует сигнал на входе IRQ0, к
которому он подключен (мы используем сквозную нумерацию входов: IRQ0-IRQ15, где
IRQ0-IRQ7 входы Master чипа, а IRQ8-IRQ15 входы Slave чипа). Контроллер
прерываний устанавливает соответствующий бит во внутреннем регистре Interrupt
Request Register в 1. После чего контроллер прерываний проверяет другой
внутренний регистр Interrupt Mask Register, чтобы проверить, что прерывание не
было замаскировано\footnote{замаскированные прерывания ждут, не замаскированные
можно передавать процессору}.

Если прерывание не было замаскировано, то нужно убедиться что нет более
приоритетных прерываний, которые ждут своей очереди\footnote{контроллер
прерываний среди прочего выполняет арбитраж прерываний, т. е. определяет
очередность обработки прерываний}. Если более приоритетных прерываний нет, то
сигнал об ожидающем обработки прерывании передается процессору.

Что должен делать процессор чтобы принять прерывание? В первую очередь,
процессор завершает выполнение текущей инструкции\footnote{это не нужно
воспринимать буквально, например, что будет текущей инструкцией, если процессор
использует конвейер?}. Затем процессор проверяет состояние бита разрешения
прерываний специального флагового регистра процессора\footnote{его называют
FLAGS, EFLAGS или RFLAGS в зависимости от режима}. Если бит разрешения
прерываний установлен, то процессор подтверждает получение прерывания подав
сигнал на специальный вход контроллера прерываний. После этого контроллер
прерываний выставляет на своих выходах номер вектора обработчика сработавшего
прерывания.

Важно отметить, что номер вектора прерывания определяет какой обработчик должен
быть вызван, чтобы обработать прерывание. И этот номер вектора может не
совпадать\footnote{и скорее всего не будет совпадать} с номером прерывания. Как
номера прерываний отображаются на номера векторов прерываний определяется во
время инициализации контроллера.

Далее контроллер прерываний выставляет бит в еще одном внутреннем регистре: In
Service Register\footnote{не трудно догадаться по названию регистра, что значит
этот бит}. Этот бит будет сброшен, когда обработчик прерывания передаст
специальную команду контроллеру прерываний. У процессора к этому времени есть
вся информация, которая нужна, чтобы обработать прерывание. К тому как имеенно
обрабатывается прерывание на стороне процессора мы вернемся после того, как
поговорим как инициализировать контроллер прерываний.

\subsection{Настройка контроллера прерываний}

Настройка контроллера прерываний осуществляется с помощью внутренних регистров
контроллер прерываний. Доступ к этим регистра осуществляется через порты
ввода/вывода.

Я уже упоминал выше несколько регистров:
\begin{itemize}
  \item Interrupt Request Register - установленный бит в этом регистре говорит,
        что есть прерывание ожидающее подтверждения со стороны процессора;
  \item In Service Register - установленный бит в этом регистре говорит, что
        прерывание было подтверждено процессором и ожидается специальная
        команда от обработчика прерывания, до тех пор пока эта команда не будет
        послана контроллеру прерываний все прерывания того же или меньшего
        приоритета не будут сигналиться процессору;
  \item Interrupt Mask Register - позволяет "замаскировать" некоторые
        прерывания, чтобы контроллер прерываний не сигнализировал о них, т. е.
        другими словами мы можем используя этот регистр выключать отдельные
        аппаратные прерывания;
\end{itemize}

Кроме упомянутых регистров есть еще несколько:
\begin{itemize}
  \item Command Register - этот регистр описывает команду, которую вы хотите
        передать контроллеру прерываний (сколько в ней будет байт, например);
  \item Status Register - этот регистр только для чтения, так что не нужен при
        настройке контроллер прерываний, поэтому мы его опустим;
  \item Data Register - в этот регистр мы записываем данные (например, данные
        нужные согласно команде, которую мы записали в Command Register).
\end{itemize}

Как уже было отмечено для обращения к этим регистрам используются порты
ввода/вывода, в частности, для обращения к Command Register и Status Register
Master контроллера используется порт 0x20\footnote{когда вы читаете из него - вы
читаете значение Status Register, а когда пишите - вы пишите в Command
Register}. Interrupt Maske Register и Data Register для Master контроллера
отображены на порт 0x21\footnote{тут все несколько сложнее, потому что в оба
регистра можно писать}. Для Slave контроллера используются порты 0xA0 и 0xA1.

Что мы должны сделать, чтобы сконфигурировать контроллер прерываний? Мы должны
указать ему в какой конфигурации они работают: кто Master, а кто Slave и как они
соединены\footnote{это необходимо, так как Legacy PIC может работать в разных
конфигурациях, хотя нас интересует только одна из множества возможных}, кроме
того мы должны указать как отображать номера прерываний на номера векторов
прерываний.

Конфигурация происходит посредством записи во внутренние регистры "командных
слов"\footnote{часто когда используют термин "слово" подразумевают 16 бит, в
данном случае это не так, под словом подразумевается 1 8-ми битный байт}. Первое
командное слово является главным, записывается в Command Register (т. е. в порты
0x20 и 0xA0) и определяет количество и смысл дальнейших слов, которые будут
записаны в Data Register (т. е. в порты 0x21 и 0xA1).

Типичное первое командное слово при инициализации контроллера состоит из
следующих бит (наименее значимый справа): 0b00010001. Смысл интересных нам бит
следующий:

\begin{itemize}
  \item bit 0 - единица в этом бите означает, что команда состоит из 4 слов
        (первое слово + 3 слова данных);
  \item bit 1 - единица в это бите значит, что в системе только один контроллер
        прерываний, а ноль, что несколько контроллеров прерываний соединены в
        каскад (конфигурация этого каскада определяется 3-им командным словом);
  \item bit 4 - должен быть установлен в 1 для команды инициализации
        контроллера.
\end{itemize}

Второе командное слово определеяет отображение номеров прерываний на номера
векторов прерываний. Legacy PIC не очень умен, поэтом отображение осуществляется
очень просто: $VECTOR_no = IRQ_no + ICW_2$, где $ICW_2$ это значение второго
командного слова. В архитектуре x86 (точнее в некоторых режимах работы
процессоров данной архитектуры) первые 32 вектора прерывания заняты исключениями
или зарезервированы, т. е. для нормальной работы $ICW_2$ должен быть 32 или
более. Типичным значением $ICW_2$ для Master является 0x20, а для Slave 0x28.

Следующее командное слово определяет конфигурацию каскада. Master контроллеру
необходимо передать в в этом слове байт, в котором установлены биты
соответствующие входам контроллера соединенным со Slave контроллерами, так как
у нас Slave контроллер подключен ко второму входу Master (считая с нуля) вы
должны передать туда 0b00000100.

Для Slave контроллера это слово интерпретируется как номер входа Master
контроллера, к которому он подключен, то есть в нашем случае это должно быть
значение 0b00000010. \footnote{Вопрос на засыпку, а как контроллер узнает каким
образом интерпретировать это слово? Мы ведь не сообщаем нигде кто из них Master,
а кто Slave? Это для тех кто жаловался на AVR...}

Наконец, последнее командное слово определяет режим работы контроллера
прерываний. Я не упоминал об этом ранее, но он может работать в нескольких
режимах, из которых нас опять же интересует только один, не вдаваясь в смысл
всех бит, командное слово должно быть следующим: 0b00000001, где нулевой
установленный бит значит, что контроллер прерываний работает в режим 8086
(режим влияет на взаимодействие контроллер и процессора на низком уровне,
который нам не особо интересен).

\subsection{Маскировка прерываний на контроллере}

Как уже упоминалось ранее у Legacy PIC есть специальный внутренний регистр,
который позволяет избирательно замаскировать прерывания - Interrupt Mask
Register. Кроме того я упоминал, что Interrupt Mask Register как и Data Register
использует порты 0x21 и 0xa1 Master и Slave контроллеров. Возникает вопрос, а
как же тогда писать в Interrupt Mask Register? Тут все довольно просто, если
запись в порт была частью команды\footnote{например, команды инициализации,
которую я описывал чуть раньше}, то контроллер интерпретирует запись согласно
ожижаниям соответствующей команды, а во всех остальных случаях это будет
считаться записью значения в Interrupt Mask Register.

\subsection{Команда подтверждения прерывания (EOI)}

Вы уже знаете, что обработчик прерывания должен послать специальную команду
контроллеру прерываний чтобы сбросить бит в In Service Register и разрешить
обработку прерываний с тем же или меньшим приоритетом. Эту команду обычно
называют EOI - End Of Interrupt.

EOI существует в двух вариантах: один указывает конкретный номер прерывания на,
которое нужно отправить подтверждение, а второй подтверждает последнее (и
значит самое приоритетное) просигналенное процессору прерывание. И вы можете
использовать любой вариант из них. Но вы должны помнить, что контроллеры
прерываний соединены в каскад. Т. е. если устройство подсоединенное к Slave
контроллеру сигналит о прерывании, то Slave контроллер сообщает об этом мастеру,
через один из его входов и таким образом устанавливается сразу два бита: один в
In Service Register Slave контроллера, а один в In Service Register Master
контроллера и вы должны сбросить оба\footnote{другими словами если прерывание
пришло на Slave, вы должны отправить подтверждение и на Slave и на Master.}.

Собственно сама команда записывается в Command Register соответствующего
контроллера прерываний и формат этой команды вы можете найти в спецификации под
именем OCW2 (Operation Control Word 2).
