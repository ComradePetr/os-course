\section{Вопросы и ответы}

\paragraph{Студент Л спрашивает:}
\emph{Вопрос общего вида -- что именно происходит в предложенном bootstrap.S и
kernel.ld? Выставляется GPT и long-mode, это видно, но что именно там записано,
и что именно происходит с сегментами кода? Какая-то часть уходит -- как мне
кажется -- по маленькому адресу памяти (из контекста он физический), какая-то
по большому (виртуальному), как всё оказывается именно там, где ожидается?}

GPT это я так понимаю GDT (Global Descriptor Table), а не GUID Partition Table?
Изначально все загружается в 32 битном защищенном режиме, это нам гарантирует
multiboot. Для того чтобы перейти в long mode нужно настроить paging и включить
этот самый long mode, ну и создать GDT для long mode (хоть он и довольно
ущербную).

Paging настраивается следующим образом. Первые 2 GB физической памяти
отображаются на 2 GB виртуальной памяти в трех местах:
\begin{itemize}
  \item начиная с 0 - для включения paging-а нам нужен identity mapping;
  \item на участок сразу за дырой в каноническом адресном пространстве - этому
        можно найти применение, понадобится ли это вам или нет, зависит от вас,
        так что подробнее эту часть описывать не буду;
  \item на 2 GB в самом верху виртуальной памяти - это собственно рабочее место
        нашего ядра (kernel.ld написан таким образом, что ядро должно жить там),
        эта часть описана в ABI.
\end{itemize}

Соответсвенно, после включения этого отображения у нас в памяти находится три
копии первых двух гигабайт физической памяти. Когда ваш код получает управление
все уже работает в верхних 2GB памяти, identity mapping при этом уже не
предполгается использовать, а использование средней части up to you.

\paragraph{Студент Л продолжает:}
\emph{И в целом, если мы дальше где-то будем оперировать регистрами сегментов (тот же bootstrap оперирует сегментами уже казалось бы в Long Mode), то зачем, у нас указатель уже накрывает размер памяти с запасом?. Что в них хранится?}

Ничего не понял.

\paragraph{Студента Л не остановить:}
\emph{Соотносятся ли это с GPT, или оно просто формирует логический адрес?}

В long mode сегментные регистры за исключением FS и GS никаким образром не
участвуют в трансляции адресов (и FS и GS участвуют в ней очень особенным
образом). Дескрипторы же вообще никак не участвую в трансляции адресов. Но
сегментные регистры и дескрипторы влияют на проверку привелегий.

\paragraph{Студент Л таки раскрывает тайну магического сокращения GPT:}
\emph{В прошлом семестре мы разбирали, как работает GPT, но только в теории, и
там мы брали готовые виртуальные адреса, смотрели по старшим битам в таблице
страниц и так далее -- всё так же?}

Вот он тот неловкий момент, когда понимаешь, что GPT - это на самом деле PT (т.
е. page table). Теперь когда я понял, что такое GPT у меня есть два сообщения.
Во-первых, не используйте не общепринятые обозначения - я очень плохо угадываю,
что имеется в этом случае ввиду (а лучше вообще избегать сокращений или
описывать их заранее, как в научных статьях по математике).

Во-вторых, принцип работы таблиц страниц одинаков на всех архитектурах,
меняются только детали: используемые флаги, количество уровней, распределение
бит адреса по уровням. В данном конкретном случае в 64-битной версии x86
используется 4 уровня, вместо 2 в 32-битной версии (на сколько я понимаю, именно
на ее примере вам и объясняли таблицы страниц).

\paragraph{Студент Л о страницах разного размера:}
\emph{И ещё в этой GPT есть, как я понял, переменная длина вхождений, то есть
страницы не одного размера -- это всё ещё дружит между собой?}

Страницы разного размера можно было создавать и в 32-битной версии x86 - тут нет
ничего нового, опять же, разница только в деталях. Например, в 64-битной версии
можно использовать страницы трех размеров: 4KB, 2MB и, иногда, 1GB - не трудно
увидеть, что эти размеры соответсвуют размерам памяти покрываемой одной записью
таблицы страниц разных уровней.

Принцип действия очень простой - в записи таблицы страниц присутсвует специльный
бит размера. Если этот бит сброшен, то запись указывает на таблицу страниц
следующего уровня (если конечно текущий уровень вообще поддерживет этот бит).
Если бит установлен то текущая запись содержит физический адрес начала "большой"
страницы, а размер страницы определяется уровнем, на котором эта запись
находится.

Задача bootstrap кода создать хоть какую-нибудь таблицу, которая покроет весь
код и данные ядра, чтобы можно было дальше работать. Пользоваться большими
страницами проще и отображение занимает меньше памяти, поэтому в bootstrap коде
используются страницы по 2MB.

Почему не 1GB страницы, ведь с ними все станет еще проще? От процессора не
требуется обязательная поддержка страниц в 1GB\footnote{хотя она, скорее всего,
присутсвует}, поэтому я и не использую 1GB страницы.

\paragraph{Студент Т спрашивает:}\emph{Скажите, при инициализации serial порта
нам не нужно задавать коэффициент деления (если я правильно понимаю, мы его нигде не используем)?}

Хитрый вопрос, короткий ответ на него - вам нужно задавать коээфициент деления.
На что у вас должен возникнуть следующий вопрос - а какой коэффициент деления
нужно использовать? И вот тут мне простым вариантом ответа не обойтись, поэтому
далее длинный вариант.

Пока вы используете QEMU коэффициент деления не важен, потому что другой
"виртуальный" конец соединения, с которым ваша ОС "общается" через
последовательный порт, будет работать при любом коэффициенте деления, просто
потому что QEMU без разницы этот коэффициент. Но если речь идет о реальном
оборудовании на другом конце соединения, то оно, скорее всего, не будет работать
с любым коэффициентом деления как QEMU, а будет ожидать какой-то конкретной
скорости передачи по последовательному интерфейсу и вам придется задать какое-то
конкретное значение.

Короче говоря, в домашнем задании задайте какой-нибудь валидный коэффициент
деления и этого будет достаточно.

\paragraph{Студент Т задает другой вопрос:}\emph{В Interrupt Enable Register
все, кроме reserved, биты должны быть единичками?}

На сколько я помню, там там наоборот должны все быть 0, потому что по заданию
вам не нужно использовать прерывания для общения с последовательным портом, а
вместо этого использовать так называемый polling mode. Т. е. вы должны
"опрашивать" контроллер последовательного порта перед тем как что-то в него
записать (или прочитать, хотя чтение из последовательного порта не требуется по
заданию).
