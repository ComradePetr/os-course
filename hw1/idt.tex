\section{Обработка прерываний и таблица векторов прерываний}

До сих пор мы касались, в основном, аппаратной части обработки прерываний -
контроллера прерываний, теперь мы будем говорить о прерываниях с программной
стороны\footnote{или, если хотите, со стороны процессора}.

Вы уже должны знать, что чтобы процессор мог принимать и обрабатывать прерывания
вы должны настроить контроллер прерываний, разрешить прерывания на процессоре
установив соответсвующий бит в флаговом регистре и не забыть в обработчике
прерывания выполнить команду EOI. Кроме того вы должны смутно подразумевать, что
нужна настроить/создать "вектора" прерываний, о которых я упоминал, но не
говорил ничего конкретного. Этот раздел как раз освещает эти моменты, но начну я
издалека - с типов прерываний.

\subsection{Типы прерываний}

Вы уже знаете о прерываниях генерируемых внешними устройствами\footnote{это
прерывания, о которых нам сообщает контроллер прерываний}, но кроме них
существуют и другие - программные прерывания. Программные прерывания не
соответствуют никаким внешним устройствам и соответсвенно никак не связаны с
контроллером прерываний.

Программные прерывания можно разделить на два класса\footnote{Деление довольно
условное, потому что грубо говоря специальной инструкцией мы можем сгенерироватьпрерывание с любым номером.}:
\begin{itemize}
  \item прерывания сгенерированные специальной инструкцией (например, int или
        into), такие прерывания мы будем называть синхронными\footnote{потому
        что они не являются неожиданными для нас, мы сами их вызвали};
  \item прерывания сгенерированные процессором в случае какой-то исключительной
        ситуации, например, при делении на ноль, или при попытке обратиться к
        недоступной памяти или использовать некорректный дескриптор;
\end{itemize}

Мы оставим первый класс на конец курса, а сейчас поговорим о втором классе. Я
упонимал, что архитектура x86 резервирует первые 32 вектора прерываний, так вот
резервирвует она их как раз для прерываний второго класса\footnote{Это не совсем
так, архитектура x86 резервирует эти прерывания под специальные нужды или на
будущее, просто так получается, что большинство из этих специальных нужд это
как раз прерывания из второго класса.}.

Прерывания второго класса также делятся на группы:
\begin{itemize}
  \item ловушки (traps) - генерируются после выполнения какой-то инструкции и
        позволяют перехватить управление после какого-то события, сделать
        грязное дело, а потом вернуть управление следующей инструкции;
  \item ошибки (faults) - соответсвуют ошибкам, которые можно поправить, что,
        впринципе, тоже можно отнести к "грязному делу", но разница между
        ловушками и ошибками в том, что после обработки ошибки прерванная
        инструкция перезапускается\footnote{Например, если была сгенерирована
        ошибка деления на 0, вы можете в обработчике прерывания подправить
        аргументы команды деления и устраить ошибку, после чего деление будет
        перезапущено};
  \item критические ошибки (aborts) - суровая версия ошибки, при которое
        перезапуск прерванной инструкции может быть невозможен, например, потому
        что адрес возврата может быть некорректен.
\end{itemize}

Примерами ошибок являются: деление на ноль, выход за границы\footnote{Это штука
позволят проверять что обращение к памяти вышло за границы массива.} или
неправильный код операции\footnote{Вы передали управление чему-то, что процессор
не может декодировать как инструкцию.}.

Примерами ловушек являются: breakpoint или переполнение.

Примеров критических ошибок немного, наиболее типичный из них носит название
double fault, и как не трудно догадаться соответсвует возникновению ошибки при
поптыке вызвать обработчик для другой ошибки (т. е. две ошибки одновременно).

Детальная классификация прерывания доступна в~\cite{INTEL:SYSV3} в разделе 6.5,
а раздел 6.15 содержит справочную информацию о всех зарезервированных
прерываниях.

\subsection{Таблица дескрипторов прерываний}

Теперь вы знаете какие бывают прерывания кроме аппаратных перейдем ближе к делу
и коснемся векторов прерываний. Вектор прерываний это, грубо говоря, информация
об обработчике прерывания - другими словами дескриптор обработчика прерывания.

Этот дескриптор по сути содержит адрес функции обработчика прерывания, причем
адрес это не просто указатель на функцию, мы также включает в понятие адреса
селектор сегмента кода (подробнее про дескрипторы можно прочитать в
\cite{INTEL:SYSV3} особенно разделы 2.1.1, 2.1.2, 2.4.1 и 3.4) и необходимый
уровень привелегий, который, впрочем, не будет интересовать нас на данном этапе.

Информация о структуре дескриптора обработчика прерывания доступна в
\cite{INTEL:SYSV3} в разделах 6.11 и 6.14.1.

Все дескрипторы обработчиков прерываний хранятся в таблица дескрипторов
обработчиков прерываний (IDT). Информация о местонахождении этой таблицы
хранится в специальном регистре IDTR. Эта информация состоит из двух частей:
\begin{itemize}
  \item базовый адрес (IDT Base Address) - просто вирутальный адрес начала
        таблицы\footnote{учтите что в 64-битном режиме этот адрес 64-битное
        число, хотя в \cite{INTEL:SYSV3} об этом явно не сказано};
  \item лимит - 16 битное число, размер таблицы в байтах минус один
        \footnote{Таким образом не обязательно создавать таблицу на все 256
        возможных векторов прерываний если они вам не нужны, с другой стороны
        вы можете создать таблицу в которой поместится больше дескрипторов
        прерываний, но использованы они не будут};
\end{itemize}

Тот самый номер вектора преррывания это ничто иное как номер дескриптора в этой
таблице, таким образом если вы отобразили аппаратные прерывания на номера
векторов прерываний начиная с 0x20, то в соответсвующе дексрипторы IDT вы и
должны сохранить информацию о соответсвующих обработчиках прерываний.

В домашнем задании вам не нужно настраивать GDT, она уже есть в готовом виде в
коде, который вам выдан вместе с заданием, а вот создать IDT вам нужно будет
самостоятельно. Для того чтобы настроить IDT вам нужно разобраться, по сути,
с двумя вещами:
\begin{itemize}
  \item формат дескриптора IDT, особенно обратите внимание на типы дексрипторов
        IDT и чем они друг от друга отличаются;
  \item как записать в регистр IDTR нужное значение - для этого используется
        специальная инструкция lidt, вам нужно разобраться как она работает;
\end{itemize}

\subsection{Обработчик прерывания}

Вы уже знаете, что обработчик аппаратного прерывания должен посылать команду EOI
контроллеру прерываний, сейчас же мы поговорим о том, что должны делать все
обработчики прерываний.

Начнем с простого, вызов обработчика прерывания очень похож на вызов функции,
разница лишь в деталях. Вызов функции в архитектуре x86 должен заканчивать
специальной инструкцией ret или какой-то из ее вариаций\footnote{Не то чтобы
прям совсем обязательно, но если вы не делаете совсем что-то изощренное, то
скорее всего используете ret или leave.}. В этом для вас не должно быть ничего
удивительного. Обработчик прерываний же должен заканчиваться инструкцией iret,
или в случае 64-битного кода инструкцией iretq.

Кроме того, для вас не должно стать неожиданностью, что обработчик прерывания
должен сохранять и восстанавливать регистры, которые он собирается испортить,
причем в отличие от обычных функций это касается почти всех регистров
\footnote{Для тех кто забыл: обработчик прерывания прерывает основной код не
давая ему подготовиться и сохранить состояние нужных ему регистров, а значит это
должен сделать сам обработчик прерывания.}.

\subsection{Включение и выключение прерываний}

Вы уже знаете как включать и выключать аппаратные прерывания на контроллере
прерываний, но контроллер прерываний это внешнее устройство, несколько более
медленное чем процессор, а необходимость включать и выключать прерывания
появляется довольно часто\footnote{Мы вернемся к этому в задании про
многопточность}. Поэтому если вы хотите выключить все прерывания, то легче
запретить прерывания сбросив флаг в флаговом регистре, о котором я упоминал
ранее. Для сброса флага разрешения прерываний используется команда cli, а чтобы
установить флаг разрешения прерываний (и тем самым включить прерывания на
процессоре) используется команда sti.
