\section{Использование QEMU}

Проще всего проверять ваше ядро не на реальной машине, а в эмуляторе. Тут у
нас есть некоторый выбор опций. ИМХО, самый удобный вариант QEMU. Так что я
покажу как пользоваться QEMU для запуска и отладки ядра.

\subsection{Запуск ядра в QEMU}

Чтобы просто запустить скомпилированное ядро в qemu нужно выполнить следующую
команду:

\begin{verbatim}
qemu-system-x86_64 -kernel kernel
\end{verbatim}

\begin{itemize}
  \item qemu-system-x86\_64 - system в навзвании значит, что мы эмулируем полную
        систему\footnote{QEMU повзоялет осуществлять эмуляцию на уровне
        процессов, т. е. вы например можете запустить Linux приложение
        собранное под ARM под QEMU на x86 и это будет даже условно сносно
        работать}, а x86\_64 это наша целевая архитектура;
  \item опция kernel позволяет указать бинарный файл ядра, бинарный файл должен
        быть multiboot или linux boot protocol совместимым (в примере выше
        используется файл с именем kernel из текущего каталога).
\end{itemize}

Если когда-нибудь вам не будет хватать производительности QEMU, то вы можете
использовать опцию --enable-kvm, если у вас достаточно современный процессор (а
это почти всегда так) и вы не пользуетесь каким-нибудь изотерическим
дистрибутивом linux, то QEMU будет использовать средства аппаратной
виртуализации архитектуры x86, что может заметно ускорить выполнение.

Иногда будет полезно указать QEMU какое количество памяти доступно
виртуализуемой системе. Это, как минимум, полезно чтобы проверить, что ваше
ядро адекватно реагирует на ситуации когда в системе не достаточно памяти или
когда ее слишком много\footnote{впрочем слишком много в QEMU всеравно не
передать.}. Для этого можно использовать опцию -m. Например:

\begin{verbatim}
qemu-system-x86_64 -kernel kernel -m 256
\end{verbatim}

команда выше говорит, что в системе должно быть 256 мегабайт виртуально памяти.
Можно также указывать суффиксы, например:

\begin{verbatim}
qemu-system-x86_64 -kernel kernel -m 1g
\end{verbatim}

теперь мы требует 1 гигабайт памяти.

Я уже упоминал, что мы не будем использовать экран, а вместо него используем
последовательный порт. QEMU позволяет соединить последоватеельный порт
виртуальной со стандартными потоками ввода/вывода самого QEMU. Другими словами
мы можем направить последовательный порт прямо к нам в терминал. Для этого можно
использовать опцию serial следующим образом:

\begin{verbatim}
qemu-system-x86_64 -kernel kernel -serial stdio
\end{verbatim}

Ну и наконец, раз нам не нужен экран, то мы можем попросить QEMU не создавать
графическое окно "виртуального экрана", это делается с помощью опции -nographic.
Впрочем, после этой опции пользоваться терминалом становится проблематично, так
что я бы не советовал ее вам использовать.

\subsection{Отладка с помощью GDB}

Самый главный плюс использования QEMU это возможность подключить отладчик. Но
в случае с QEMU, x86\_64 и GDB есть некоторая тонкость. Для начала, чтобы можно
было подключить отладчик нужно указать QEMU опцию -s:

\begin{verbatim}
qemu-system-x86_64 -kernel kernel -s
\end{verbatim}

После этого к QEMU можно подключиться с помощью GDB. Для этого запустите GDB и введи в нем слующие команды:

\begin{verbatim}
set architecture i386:x86-64
target remote localhost:1234
\end{verbatim}

После этого QEMU остановится и вы можете делать все что вы можете делать с
обычными userspace программами используя дебагер. Однако, если вы хотите
остановить выполнение QEMU в самом начале загрузки ядра, перед стартом функции
main\footnote{а обычно вы этого и хотите}, а не в случайном месте до которого
дошло ваше ядро пока вы набирали команды в GDB, то тут есть небольшая проблема.

Обычно в QEMU для этого используется опция -S, но в данном случае она нам не
поможет. Причина в том, что ядро запускается изначально в 32 битном режиме и
опция -S остановит ядро в самом начале 32 битном режиме, после чего ядро
переводит процессор в 64 битный режим и в этом переходе из одного режима в
другой заключается проблема: QEMU или GDB не могут адекватно обработать этот
переход\footnote{QEMU винят GDB-шников, GDB-шникам много раз прислыали разные
патчи на испраление этого дела, но ниодин им не угодил, а мне без разницы кто
винова - я хочу чтобы работало, поэтому приходится придумывать обходные пути.}.

В связи с тем, что вам врядли придется отлаживать 32 битную часть кода или сам
переход из 32 битного кода в 64 битный, то вам может помочь следующий хак. Я
упоминал про файл kernel\_config.h и про одну единственную опцию, которая там
в данный момент есть: CONFIG\_QEMU\_GDB\_HANG. Если вы поищете использование
этой опции в bootstrap.S то вы увидите, что она включает/выключает бесконечный
цикл перед самым вызовом функции main в bootstrap.S. Таким образом, если вы
раскоменнтируете define в kernel\_config.h ядро зависнет после перехода в
64 битный режим перед вызовом функции main.

Пока ядро крутится в бесконечном цикле вы можете неторопясь подключиться к нему
с помощью GDB, настроить все нужные вам breakpoint-ы или загрузить дебажную
информацию, а после чего вам нужно выйти из бесконечного цикла, например,
используя команду jump GDB. Таким образом вы без проблем подключитесь к QEMU
после перехода в 64 битный режим, но до вызова main.
